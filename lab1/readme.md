# lab1 进程创建与管理

## 实验环境

- OS: Arch Linux
- Kernel Version：6.5.9-arch2-1 (64-bit)

## 1-1 进程观察

参照 Linux 内核源码结构,阅读 Linux 内核源码,分析 Linux 进程的组成,观察 Linxu 进程的 task_struct 等进程管理数据结构;

### `task_struct`

为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块 PCB（Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个 PCB，在创建进程时，建立 PCB，伴随进程运行的全过程，直到进程撤销而撤销。PCB 记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息（如打开的文件、挂起的信号、进程状态、地址空间等等）。

在 Linux 中每一个进程都由 `task_struct` 数据结构来定义。`task_struct` 就是我们通常所说的 PCB。它是对进程控制的唯一手段也是最有效的手段。当我们调用 `fork()`  时，系统会为我们产生一个 `task_struct` 结构。然后从父进程，那里继承一些数据，并把新的进程插入到进程树中，以待进行进程管理。因此了解 `task_struct` 的结构对于我们理解任务调度(在 Linux 中任务和进程是同一概念)的关键。

在进行剖析 task_struct 的定义之前，我们先按照我们的理论推一下它的结构：

1. 进程状态，将纪录进程在等待，运行，或死锁；
2. 调度信息，由哪个调度函数调度，怎样调度等；
3. 进程的通讯状况；
4. 因为要插入进程树，必须有联系父子兄弟的指针，当然是 task_struct 型；
5. 时间信息，比如计算好执行的时间，以便 CPU 分配；
6. 标号，决定该进程归属；
7. 可以读写打开的一些文件信息；
8. 进程上下文和内核上下文；
9. 处理器上下文；
10. 内存信息；

因为每一个PCB都是这样的，只有这些结构，才能满足一个进程的所有要求。

`task_struct` 结构体包含了一个进程所需的所有信息。

它定义在内核模块的 `/usr/lib/modules/6.5.9-arch2-1/build/include/linux/sched.h` 文件中。

在 Linux 内核编程中常用的 `CURRENT` 宏可以非常简单地获取到指向 `task_struct` 的指针。

## 1-2 进程创建与管理

### `unistd.h`

C 语言标准库中的 `<unistd.h>` 头文件提供了对 POSIX（可移植操作系统接口）的访问，它定义了一些与操作系统交互的函数、常量和类型。该头文件通常在 Unix 或类 Unix 系统中使用，如 Linux、macOS 和其他类 Unix 操作系统。

`<unistd.h>` 头文件提供了以下一些常用函数和常量：

1. 文件和 I/O：
   - `read()`：从文件描述符读取数据。
   - `write()`：将数据写入文件描述符。
   - `close()`：关闭文件描述符。
   - `access()`：检查文件是否存在或具有指定权限。
   - `pipe()`：创建一个管道。
2. 进程控制：
   - `fork()`：创建一个子进程。
   - `exec()` 系列函数：用于执行其他程序。
   - `exit()`：终止当前进程。
3. 系统调用和系统信息：
   - `chdir()`：改变当前工作目录。
   - `getpid()`：获取当前进程的 ID。
   - `getuid()` 和 `geteuid()`：获取用户 ID。
   - `getgid()` 和 `getegid()`：获取组 ID。
   - `sleep()`：使进程休眠一段时间。
4. 其他功能：
   - `gethostname()`：获取主机名。
   - `getopt()`：用于解析命令行参数。

### `sys/types.h`

`<sys/types.h>` 是 C 语言标准库中的系统类型头文件，它定义了一些基本的系统数据类型。该头文件通常在 Unix 或类 Unix 系统中使用，如 Linux、macOS 和其他类 Unix 操作系统。

以下是 `<sys/types.h>` 头文件中定义的一些重要类型：

1. 基本数据类型：
   - `size_t`：无符号整数类型，用于表示对象的大小。
   - `ssize_t`：有符号整数类型，用于表示对象的大小。
2. 进程和线程标识符：
   - `pid_t`：进程标识符类型。
   - `pthread_t`：线程标识符类型。
3. 文件标识符：
   - `int`：用于表示文件描述符的整数类型。
4. 时间和日期类型：
   - `time_t`：用于表示时间值的整数类型。
   - `clock_t`：用于表示处理器时钟时间的整数类型。
5. 用户和组标识符：
   - `uid_t`：用户标识符类型。
   - `gid_t`：组标识符类型。
6. 文件系统相关类型：
   - `ino_t`：用于表示文件索引节点号的整数类型。
   - `dev_t`：用于表示设备号的整数类型。
   - `mode_t`：用于表示文件权限和类型的整数类型。

`<sys/types.h>` 头文件的主要作用是为系统提供一些基本的数据类型，这些类型在系统编程中经常用到。这些类型的定义可以使程序在不同的系统上具有可移植性，因为它们的定义会根据特定的系统进行适配。

### `fork()`

`fork()` 函数创建一个新进程。正确返回时，等于 0 表示创建子进程，从子进程返回的 ID 值；大于 0 表示从父进程返回的子进程的进程 ID 值。错误返回时，等于 -1 表示创建失败。

用法举例：

```c
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>

int main(int argc, char** argv)
{
	if ((pid = fork()) > 0) {
		printf("I am the parent process.\n");
    	/* 父进程处理过程 */
    } else if (pid == 0) {
        printf("I am the child process.\n");
        /* 子进程处理过程 */
        exit(0)
    } else {
        printf("fork error\n");
        exit(0);
    }
}
```

`fork()` 用来创建一个新的进程，该进程几乎是当前进程的一个完全复制；`exec()` 用来启动另外的进程以取代当前运行的讲程。

### `clone()`

`clone()` 用于创建 Linux 线程。创建时可以通过多个参数，指定新的命名空间（namespace），有选择地继承父进程的资源（如虚拟内存空间），将创建的子进程指定为父进程的兄弟进程。当创建出的子进程与父进程共享同一虚拟内存空间时，子进程被认为是线程。

如果该调用执行成功，所创建的子进程的 threadID 将返回给调用者；如果该调用执行失败，-1 将返回给调用者。

`clone()` 函数的原型如下：

```c
#include <sched.h>

int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...
           /* pid_t *ptid, void *newtls, pid_t *ctid */ );
```

参数说明：

- `fn`：一个函数指针，指向子进程或子线程的入口函数。它接受一个 `void*` 类型的参数，并返回一个 `int` 类型的值。在子进程或子线程开始执行时会调用此函数。
- `child_stack`：指向子进程或子线程的栈空间的指针。栈是存储函数调用和局部变量的内存区域。
- `flags`：用于设置创建新执行上下文的一些选项和属性，例如共享地址空间、共享文件描述符等。
- `arg`：传递给子进程或子线程入口函数的参数。

`clone()` 函数返回值表示创建的新进程或线程的状态，如果创建成功，则返回子进程或子线程的 ID；如果发生错误，则返回 -1。

`flags` 的主要取值如下：

| 标志            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `CLONE_PARENT`  | 创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子” |
| `CLONE_FS`      | 子进程与父进程共享相同的文件系统，包括 root、当前目录、umask。<br/>如果设置该参数，调用者父进程对于 `chroot(2)`，`chdir(2)`，`umask(2)` 的调用，同样会影响到创建的子进程，反之亦然；如果没有设置 `CLONE_FS`，子进程将工作在调用者父进程的文件系统信息的拷贝上，父进程对于 `chroot(2)`，`chdir(2)`，`umask(2)` 的调用不会影响子进程，反之亦然。 |
| `CLONE_FILES`   | 如果设置该参数,子进程与父进程共享相同的文件描述符（file descriptor）表。<br/>调用者父进程创建的文件描述符对于被创建的子进程同样有效，反之亦然。例如，父进程或子进程中的一个关闭了文件描述符，另一个进程也会受影响。 |
| `CLONE_NEWNS`   | 在新的 namespace 启动子进程，namespace 描述了进程的文件 hierarchy |
| `CLONE_SIGHAND` | 子进程与父进程共享相同的信号处理（signal handler）表         |
| `CLONE_PTRACE`  | 若父进程被 trace，子进程也被 trace                           |
| `CLONE_VFORK`   | 如果设置该参数，调用者父进程被挂起，直至所创建的子进程通过 `execve(2)` 或 `_exit(2)` （as with `vfork(2)`） 释放虚拟内存资源后，父进程才重新激活。<br/>如果没有设置该参数，父进程和子进程并发执行，都是可调度的。 |
| `CLONE_VM`      | 如果设置该参数，子进程与父进程运行于相同的内存空间中。对调用者父进程或被创建子进程，其中一个进程的内存写操作对另一个进程是可见的，即会影响到另一个进程。而且，由父进程或子进程通过 `mmap` 或 `munmap` 执行的内存映射或解映射操作，同样会影响到另一个进程。<br/>如果没有设置 `CLONE_VM`，子进程在 `clone()` 时在调用进程的内存空间的单独副本中运行，其中一个进程执行的内存写入不会影响另一个进程，就像 `fork()` 一样。 |
| `CLONE_PID`     | 如果设置该参数，子进程创建时得到的 PID 与父进程 PID 一致，可用于 hacking the system。 |
| `CLONE_THREAD`  | 支持 POSIX 线程标准，子进程与父进程共享相同的线程群。        |

`clone()` 函数的使用方式可以根据具体的需求和场景而有所不同，下面是一个示例：

```c
#include <stdio.h>
#include <unistd.h>
#include <sched.h>

int child_function(void *arg) {
    printf("Child process: Hello, world!\n");
    return 0;
}

int main() {
    char child_stack[8192];  // 子进程栈空间
    int child_pid;

    // 创建子进程
    child_pid = clone(child_function, child_stack + sizeof(child_stack), CLONE_VM | SIGCHLD, NULL);
    if (child_pid == -1) {
        perror("clone");
        return 1;
    }

    printf("Parent process: Created child process with PID %d\n", child_pid);
    sleep(1);  // 等待子进程执行完毕

    return 0;
}
```

在上面的示例中，我们首先定义了一个 `child_function` 函数作为子进程的入口函数。然后，我们在 `main` 函数中调用 `clone()` 函数来创建一个新的子进程。通过设置 `CLONE_VM` 标志，我们让子进程与父进程共享地址空间。`SIGCHLD` 标志表示在子进程退出时会向父进程发送 `SIGCHLD` 信号。

在父进程中，我们打印出创建的子进程的 ID，并使用 `sleep()` 函数等待子进程执行完毕，以避免父进程先于子进程退出。

#### `clone()` 和 `fork()` 的区别:

1. `clone()` 需要通过参数传入一个函数，作为子进程的执行体，在创建的子进程中执行
2. `clone()` 不复制父进程的栈空间，而是通过第 2 个参数 `(void *child_stack)` 为创建的子进程分配一个新的栈空间，需要分配栈指针的空间大小。因此，`clone()` 不再是简单地继承或者复制父进程
3. `fork()` 函数创建的子进程完全拷贝父进程，`clone()` 则是有选择性地拷贝

### `exec()`

`exec()` 系统调用族是一组用于在 Unix 或类 Unix 操作系统上执行新程序的函数。它们将当前进程替换为新的可执行程序，从而启动一个新的程序执行流。`exec()` 系统调用族是进程创建和程序加载的核心机制之一。

在 C 语言中，`exec()` 系统调用族提供了多个函数来执行不同类型的程序。这些函数的原型和功能略有不同，但它们都具有相同的目标：加载并执行一个新的程序。

以下是 `exec()` 系统调用族中常用的函数：

1. `int execl(const char *path, const char *arg0, ...);`
   - 使用给定的参数列表执行一个可执行文件。
   - 参数 `path` 是要执行的可执行文件的路径。
   - 参数 `arg0` 是新程序的第一个参数，后面可以跟随更多的参数，以 `NULL` 结尾。
2. `int execv(const char *path, char *const argv[]);`
   - 使用给定的参数数组执行一个可执行文件。
   - 参数 `path` 是要执行的可执行文件的路径。
   - 参数 `argv` 是一个以 `NULL` 结尾的字符串数组，表示新程序的参数列表。
3. `int execle(const char *path, const char *arg0, ... , char *const envp[]);`
   - 使用给定的参数列表和环境变量执行一个可执行文件。
   - 参数 `path` 是要执行的可执行文件的路径。
   - 参数 `arg0` 是新程序的第一个参数，后面可以跟随更多的参数，以 `NULL` 结尾。
   - 参数 `envp` 是一个以 `NULL` 结尾的字符串数组，表示新程序的环境变量列表。
4. `int execve(const char *path, char *const argv[], char *const envp[]);`
   - 使用给定的参数数组和环境变量执行一个可执行文件。
   - 参数 `path` 是要执行的可执行文件的路径。
   - 参数 `argv` 是一个以 `NULL` 结尾的字符串数组，表示新程序的参数列表。
   - 参数 `envp` 是一个以 `NULL` 结尾的字符串数组，表示新程序的环境变量列表。
5. `int execvp(const char *file, char *const argv[]);`
   - 根据给定的文件名和参数数组在系统的路径中查找可执行文件，并执行它。
   - 参数 `file` 是要执行的可执行文件的文件名。
   - 参数 `argv` 是一个以 `NULL` 结尾的字符串数组，表示新程序的参数列表。

这些 `exec()` 函数在执行新程序时，会使用新的可执行文件替换当前进程的代码和数据段，从而启动新程序的执行。它们不会创建新的进程，而是将当前进程转换为新程序的上下文。因此，之后的代码和数据将完全由新程序接管。

需要注意的是，`exec()` 系统调用族的函数在执行成功时不会返回，除非发生错误。如果调用成功，当前进程将被新程序替换，新程序会从其入口点开始执行。如果发生错误，这些函数将返回 -1，并设置 `errno` 变量以指示错误的具体原因。

用法举例：

```c
#include<unistd.h>

int main(int arge, char*argv[])
{
	char *envp[] = {"PATH=/tmp”, "USER=1ei", "STATUS = testing", NULL};
	char *argv_execv[] = {"echo", "excuted by execv", NULL};
	char *argv_execvp[] = {"echo", "excuted by execvp", NULL};
	char *argv_execve[] = {"env", NULL};

	if(fork() == 0) {
		if(execl("/bin/echo","echo","executed by execl",NULL) < 0)
			perror("Err on execl");
	}

	if(fork() == 0) {
		if(execlp("echo", "echo", "executed by execlp", NULL) < 0)
			perror("Err on execlp");
	}

	if(fork() == 0) {
		if(execle("/usr/bin/env", "env", NULL, envp) < 0)
			perror("Err on execle");
	}

	if(fork() == 0) {
		if(execv("/bin/echo", argv_execv) < 0)
			perror("Err on execv");
	}

	if(fork() == 0) {
		if(execvp("echo", argv_execvp) < 0)
			perror("Err on execvp");
	}

	if(fork() == 0) {
		if(execve("/usr/bin/env", argv_execve, envp) < 0)
			perror("Err on execve");
	}
```

程序中调用了 `echo` 和 `env` 两个系统命令，`echo` 打印后面的命令行参数，`env` 用于列出所有环境变量。

由于各个子进程执行的顺序无法控制，因此有可能出现一个比较混乱的输出---各子进程打印的结果交杂在一起，而不是严格按照程序中列出的次序。

### `wait()`

`wait()` 用于控制父进程与子进程的同步。父进程调用 `wait()` 函数，则父进程被阻塞，进入等待队列，等待子进程结束。当子进程结束时，会产生一个终止状态字，系统会向父进程发出 `SIGCHLD` 信号。当接到信号后，父进程提取子进程的终止状态字，从 `wait()` 函数返回继续执行原程序。

调用格式：

```c
#include <ays/type.h>
#include<sys/wait.h>
(pid t) wait(int *statloc);
```

返回值：

- 正确返回时：大于 0 ，表示子进程的进程 ID 值；等于 0 表示其他。
- 错误返回时：等于 -1 表示调用失败。

### `exit()`

`exit()` 用于结束进程自身。在进程正常结束时，`exit()` 函数返回进程结束状态。在主程序 main 函数中调用 return，实际是调用 `exit()` 函数。

调用格式：

```c
#include<stdio.h>
void exit(int status);
```

其中，`status` 为进程结束状态，0 表示正常退出，其他表示异常退出，含义由调用函数确定。

### `kill()`

`kill()` 函数用于删除执行中的程序或者任务。

调用格式：

```c
kill(int PID, int IID);
```

其中，`PID` 为要被 kill 的进程号，`IID` 为向将被 kill 的进程发送的中断号。

### `signal()`

`signal()` 是一个用于处理信号的系统调用函数，用于在 Unix 或类 Unix 操作系统上设置信号处理程序。它允许进程定义在接收到特定信号时应执行的操作。信号是在操作系统或其他进程中发生的事件的异步通知机制。`signal()` 函数支持进程间基于信号 signal（也称为软中断）的通信机制，允许调用进程控制软中断信号的处理。

以下是 `signal()` 函数的原型：

```c
#include <signal.h>

void (*signal(int signum, void (*handler)(int)))(int);
```

`signal()` 函数接受两个参数：

- `signum`：表示要设置处理程序的信号编号，可以是预定义的信号宏（如 `SIGINT`、`SIGTERM`）或信号编号。
- `handler`：一个函数指针，指向要用于处理信号的处理程序的函数。

`signal()` 函数的返回类型是一个函数指针，指向以前设置的信号处理程序。在成功设置信号处理程序之前，它返回 `SIG_ERR`。

`void (*signal(int signum, void (*handler)(int)))(int);` 是一个复杂的函数声明，涉及到函数指针和函数指针的返回类型。下面对其进行逐步解释：

1. `signal`：这是函数的名称，它接受两个参数并返回一个函数指针。
2. `int signum`：这是 `signal` 函数的第一个参数，表示要设置处理程序的信号编号。它是一个整数类型。
3. `void (*handler)(int)`：这是 `signal` 函数的第二个参数，表示一个函数指针。函数指针的名称是 `handler`，它指向一个以整数参数和无返回值的函数。
4. `(int)`：这是函数指针的返回类型。它表示指向的函数接受一个整数参数，并且返回值为整数。
5. `void (*signal(int signum, void (*handler)(int)))(int)`：这是函数 `signal` 的完整声明。它表示 `signal` 函数接受一个整数参数 `signum` 和一个指向以整数参数并返回整数的函数的指针 `handler`，并返回一个指向以整数参数并返回无值的函数的指针。

信号处理程序是一个函数，它定义了在接收到特定信号时要执行的操作。信号处理程序的原型如下：

```c
void handler_function(int signum);
```

它接受一个整数参数 `signum`，表示接收到的信号编号。

在使用 `signal()` 函数设置信号处理程序时，有三种主要的处理方式：

1. `SIG_DFL`（默认处理程序）：使用默认的信号处理程序。对大多数信号，这意味着采取默认的操作，如终止进程（`SIGTERM`）或中止进程（`SIGABRT`）。
2. `SIG_IGN`（忽略信号）：忽略接收到的信号，不执行任何操作。对某些信号，如 `SIGCHLD`，忽略是有意义的，因为它们表示某些子进程的状态变化。
3. 自定义信号处理程序：一个用户定义的函数，用于在接收到信号时执行特定的操作。可以编写自定义的信号处理程序来处理各种信号，如捕获 `SIGINT` 信号并进行清理操作后再终止进程。

以下是一个示例，展示如何使用 `signal()` 函数来设置信号处理程序：

```c
#include <stdio.h>
#include <signal.h>

void signal_handler(int signum) {
    printf("Received signal: %d\n", signum);
}

int main() {
    // 设置 signal_handler 作为 SIGINT 的信号处理程序
    signal(SIGINT, signal_handler);

    printf("Waiting for signal...\n");
    while (1) {
        // 做一些其他的工作
    }

    return 0;
}
```

在上面的示例中，我们定义了一个名为 `signal_handler` 的信号处理程序，它仅打印接收到的信号编号。然后，在 `main()` 函数中使用 `signal()` 函数将 `signal_handler` 设置为 `SIGINT`（键盘中断）的信号处理程序。接下来，程序进入一个无限循环，等待信号的到来。

当用户在终端按下 Ctrl+C 时，会生成 `SIGINT` 信号并调用 `signal_handler` 函数来处理信号。在信号处理程序中，我们打印出接收到的信号编号。程序将继续等待信号，并重复此过程。

`signum` 取值如下：

| Signum | 信号名称 | 描述                                    |
| :----- | :------- | :-------------------------------------- |
| 1      | SIGHUP   | 挂起                                    |
| 2      | SIGINT   | 中断（通常由 Delete 键或 Break 键生成） |
| 3      | SIGQUIT  | 退出（通常由 Ctrl+Q 生成）              |
| 4      | SIGILL   | 非法指令                                |
| 5      | SIGTRAP  | 跟踪中断                                |
| 6      | SIGIOT   | IOT 指令                                |
| 7      | SIGBUS   | 总线错误                                |
| 8      | SIGFPE   | 浮点运算溢出                            |
| 9      | SIGKILL  | 终止进程                                |
| 10     | SIGUSR1  | 用户定义信号 1                          |
| 11     | SIGSEGV  | 段错误                                  |
| 12     | SIGUSR2  | 用户定义信号 2                          |
| 13     | SIGPIPE  | 管道断裂（向无读者管道写入）            |
| 14     | SIGALRM  | 定时器警报（时间到）                    |
| 15     | SIGTERM  | 终止（软件终止信号，由 kill 发出）      |
| 17     | SIGCHLD  | 子进程终止或停止                        |

### `getpid()`

`getpid()` 是一个系统调用，用于获取当前进程的进程 ID（Process ID）。它是 POSIX 标准中定义的一个函数，通常用于进程间通信、进程管理和调试等场景。

当调用 `getpid()` 时，操作系统会返回调用进程的唯一标识符，即进程 ID。每个运行中的进程都被分配了一个唯一的进程 ID，用于在系统中标识和区分不同的进程。进程 ID是一个非负整数，通常由操作系统根据一定规则进行分配。

`getpid()` 函数的原型如下：

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
```

- `sys/types.h`：头文件包含了一些基本的系统数据类型，其中包括 `pid_t` 类型。
- `unistd.h`：头文件包含了各种系统调用和常量的定义，包括 `getpid` 函数。

`getpid()` 函数没有参数，直接调用即可。它返回一个 `pid_t` 类型的值，表示当前进程的进程 ID。

使用 `getpid()` 可以在进程中获取自身的进程ID，然后可以根据需要进行进一步的处理，比如与其他进程进行通信、记录日志、生成唯一标识符等。

## 1-3 进程管理命令

了解 ps、top、pstree –h、vmstat、strace、ltrace、sleep x、kill、jobs 等命令的功能，使用这些命令观察进程结构和行为

### `ps`

`ps` 是一个常用的命令行工具，用于在 Linux 和 Unix 系统上查看当前运行的进程信息。它提供了对系统中活动进程的实时监视和查询功能。

`ps` 命令的基本语法如下：

```zsh
ps [options]
```

`ps` 命令可以使用不同的选项来过滤和显示不同的进程信息。以下是一些常用的选项：

- `-e` 或 `--everyone`：显示所有进程，包括其他用户的进程。
- `-f` 或 `--full`：显示完整的进程信息，包括进程的父进程ID、CPU 使用率、内存占用等。
- `-l` 或 `--long`：以长格式显示进程信息，包括进程的状态、启动时间等。
- `-u` 或 `--user <用户>`：显示指定用户的进程信息。
- `-p` 或 `--pid <进程ID>`：显示指定进程ID的进程信息。
- `-j`：以作业格式显示进程信息，包括作业控制信息。

除了上述选项外，`ps` 命令还可以与其他命令和管道结合使用，以进一步过滤和处理进程信息。

以下是一些示例用法：

- `ps`：显示当前用户的运行进程。
- `ps -e`：显示所有正在运行的进程。
- `ps -f`：显示详细的进程信息，包括父进程ID和CPU使用情况。
- `ps -u username`：显示指定用户的进程信息。
- `ps -p pid`：显示指定进程ID的进程信息。

`ps` 命令的输出结果包括进程的状态、进程ID（PID）、父进程ID（PPID）、CPU 使用率、内存占用等信息，可以根据需要进行进一步的分析和处理。

请注意，不同的操作系统和版本可能会有稍微不同的 `ps` 命令选项和输出格式，请根据实际情况参考相应的文档或使用 `man ps` 命令查看详细的帮助信息。

### `top`

`top` 是一个常用的命令行工具，用于实时监视和管理 Linux 和 Unix 系统上运行的进程。它以交互式的方式显示系统的状态信息，包括各个进程的 CPU 占用、内存使用、进程ID、用户、运行时间等。

`top` 命令的基本语法如下：

Copy

```zsh
top [options]
```

`top` 命令会在终端中显示一个实时的进程列表，并在顶部显示系统的总体状态信息，如系统负载、CPU 使用率、内存占用等。在进程列表中，每一行代表一个运行的进程，显示了进程的相关信息，如进程ID（PID）、CPU 占用率、内存占用、进程状态、进程命令等。

以下是一些常用的 `top` 命令选项：

- `-d <秒数>`：指定刷新间隔时间，默认为 3 秒。
- `-n <次数>`：指定刷新次数，达到指定次数后自动退出。
- `-p <进程ID>`：只显示指定进程ID的进程信息。
- `-u <用户名>`：只显示指定用户名的进程信息。
- `-H`：显示进程的层次结构。

在 `top` 的交互界面中，你可以使用不同的按键来执行特定的操作，如：

- `k`：终止一个进程。
- `r`：修改进程的优先级。
- `f`：添加或删除显示的字段。
- `s`：改变刷新间隔时间。
- `q`：退出 `top`。

通过使用 `top` 命令，你可以实时监视系统的性能和进程的活动情况，了解系统资源的使用情况，以及快速识别和解决可能存在的性能问题。

请注意，`top` 命令在不同的操作系统和发行版中可能有稍微不同的选项和输出格式，请根据实际情况参考相应的文档或使用 `man top` 命令查看详细的帮助信息。

可以考虑更加功能强大的 `bashtop` 来替代 `top`

### `pstree`

`pstree` 是一个命令行工具，用于以树状结构显示当前系统上运行的进程及其之间的父子关系。它可以帮助你更直观地了解进程之间的层次结构和关联关系。

`pstree` 命令的基本语法如下：

```zsh
pstree [options]
```

`pstree` 命令会以树状结构的形式显示当前系统中的进程。默认情况下，它会显示当前用户的进程树。每个进程都以一个节点表示，并通过缩进来显示进程之间的层次关系。父进程位于上方，子进程位于下方。

以下是一些常用的 `pstree` 命令选项：

- `-p`：显示进程的进程ID。
- `-h`：高亮显示当前进程。
- `-u`：显示进程的所有者。
- `-a`：以ASCII字符显示树状结构。

示例用法：

- `pstree`：显示当前用户的进程树。
- `pstree -p`：显示进程树，并显示进程的进程ID。
- `pstree -h`：高亮显示当前进程所在的进程树。

通过使用 `pstree` 命令，你可以更清晰地了解进程之间的层次结构和关联关系。这对于理解进程之间的相互作用、调试进程相关问题以及监视进程的行为都非常有用。

请注意，`pstree` 命令在不同的操作系统和发行版中可能有稍微不同的选项和输出格式，请根据实际情况参考相应的文档或使用 `man pstree` 命令查看详细的帮助信息。

### `vmstat`

`vmstat` 是一个命令行工具，用于监视和报告 Linux 和 Unix 系统上的虚拟内存、进程、CPU 和 I/O 等性能统计信息。它提供了实时的系统性能监控和分析功能，有助于识别系统资源瓶颈和性能问题。

`vmstat` 命令的基本语法如下：

```zsh
vmstat [options] [interval] [count]
```

`vmstat` 命令可以通过不同的选项来显示不同类型的性能统计信息。以下是一些常用的选项：

- `-a`：显示活动和非活动内存的统计信息。
- `-s`：以摘要形式显示内存和交换空间的统计信息。
- `-d`：显示磁盘 I/O 统计信息。
- `-p <磁盘>`：限制磁盘 I/O 统计信息仅显示指定的磁盘。
- `-t`：显示进程和任务统计信息。
- `-w`：宽输出模式，用于适应宽屏显示。

`interval` 参数指定了采样的时间间隔（以秒为单位），`count` 参数指定了采样的次数。如果不指定这两个参数，`vmstat` 将会持续输出实时的性能统计信息。

`vmstat` 命令的输出结果包括以下几个方面的信息：

- 进程统计信息：包括运行进程数、睡眠进程数、僵尸进程数等。
- 虚拟内存统计信息：包括内存使用情况、页面交换情况等。
- CPU 统计信息：包括用户态、系统态和空闲时间的 CPU 使用情况。
- I/O 统计信息：包括块设备的读写操作、磁盘 I/O 等。

通过使用 `vmstat` 命令，你可以实时监控系统的性能指标，了解系统的负载、内存使用、CPU 使用、I/O 等情况，以及快速发现和解决潜在的性能问题。

请注意，`vmstat` 命令在不同的操作系统和发行版中可能有稍微不同的选项和输出格式，请根据实际情况参考相应的文档或使用 `man vmstat` 命令查看详细的帮助信息。

### `strace`

`strace` 是一个命令行工具，用于跟踪和调试 Linux 和 Unix 系统上进程的系统调用和信号。它可以帮助开发人员和系统管理员了解进程的行为、识别问题和进行故障排除。

`strace` 命令的基本语法如下：

```zsh
strace [options] command
```

`strace` 命令通过启动指定的 `command`，跟踪并记录该进程所执行的系统调用和接收的信号。它会输出每个系统调用的相关信息，如系统调用号、参数、返回值等。同时，它还可以显示进程的信号处理过程、CPU 寄存器状态等调试信息。

以下是一些常用的 `strace` 命令选项：

- `-p <进程ID>`：跟踪指定进程ID的进程。
- `-o <文件>`：将输出结果重定向到指定文件。
- `-c`：显示系统调用的统计信息。
- `-e <系统调用>`：指定要跟踪的系统调用。
- `-s <长度>`：限制打印字符串的长度。
- `-t`：在输出中显示时间戳。

示例用法：

- `strace ls`：跟踪并记录 `ls` 命令执行过程中的系统调用。
- `strace -p 1234`：跟踪进程ID为 1234 的进程。
- `strace -o output.txt ls`：将 `ls` 命令执行过程中的输出结果保存到文件 `output.txt`。

通过使用 `strace` 命令，你可以深入了解进程执行过程中的系统调用，包括文件操作、网络通信、进程管理等。这对于分析进程的行为、追踪问题、调试代码以及进行系统性能优化都非常有用。

请注意，`strace` 命令需要在具有足够权限的环境中运行，因为它会访问和监视系统的底层调用。此外，`strace` 命令的输出可能会非常详细和庞大，需要根据具体情况进行筛选和分析。

### `ltrace`

`ltrace` 是一个命令行工具，用于跟踪和调试 Linux 和 Unix 系统上运行的程序的库函数调用。它可以帮助开发人员和系统管理员了解程序在运行过程中调用的库函数，以及参数和返回值等信息。

`ltrace` 命令的基本语法如下：

```zsh
ltrace [options] command
```

`ltrace` 命令通过启动指定的 `command`，跟踪并记录该程序所调用的库函数。它会输出每个库函数的相关信息，如函数名、参数值、返回值等。同时，它还可以显示函数调用的堆栈信息、调用次数等调试信息。

以下是一些常用的 `ltrace` 命令选项：

- `-p <进程ID>`：跟踪指定进程ID的程序。
- `-o <文件>`：将输出结果重定向到指定文件。
- `-c`：显示库函数的调用次数。
- `-e <函数>`：指定要跟踪的库函数。
- `-s <长度>`：限制打印字符串的长度。
- `-t`：在输出中显示时间戳。

示例用法：

- `ltrace ls`：跟踪并记录 `ls` 命令执行过程中调用的库函数。
- `ltrace -p 1234`：跟踪进程ID为 1234 的程序。
- `ltrace -o output.txt ls`：将 `ls` 命令执行过程中的输出结果保存到文件 `output.txt`。

通过使用 `ltrace` 命令，你可以深入了解程序在运行过程中调用的库函数，包括文件操作、内存管理、字符串处理等。这对于分析程序的行为、追踪问题、调试代码以及进行性能优化都非常有用。

请注意，`ltrace` 命令需要在具有足够权限的环境中运行，因为它会访问和监视程序的库函数调用。此外，`ltrace` 命令的输出可能会非常详细和庞大，需要根据具体情况进行筛选和分析。

### `sleep`

`sleep` 是一个命令行工具，用于在指定的时间间隔内暂停程序的执行。它通常用于脚本或命令中，用于延迟程序的执行，或者创建一个简单的定时器。

`sleep` 命令的基本语法如下：

```zsh
sleep <时间>
```

其中，`<时间>` 指定了暂停的时间长度，可以使用整数或带有单位的时间值。常用的时间单位包括秒（s）、分钟（m）、小时（h）等。

示例用法：

- `sleep 5`：暂停程序的执行 5 秒钟。
- `sleep 1m`：暂停程序的执行 1 分钟。
- `sleep 2h`：暂停程序的执行 2 小时。

`sleep` 命令可以与其他命令或脚本结合使用，用于实现一些需要延迟执行的操作，例如执行定时任务、在循环中添加延迟等。

请注意，`sleep` 命令是一个阻塞式命令，执行时会暂停当前进程的执行，直到指定的时间间隔过去后再继续执行后续的命令。在某些情况下，可能需要使用信号来中断 `sleep` 命令的执行。

`sleep` 命令在不同的操作系统和发行版中可能会有一些差异，请根据实际情况参考相应的文档或使用 `man sleep` 命令查看详细的帮助信息。

### `kill`

`kill` 是一个命令行工具，用于向正在运行的进程发送信号，以控制进程的行为。它通常用于终止或操作进程，例如关闭不响应的程序、重新加载配置文件、发送特定的信号等。

`kill` 命令的基本语法如下：

```zsh
kill [options] <进程ID>
```

其中，`<进程ID>` 指定了要发送信号的目标进程的进程ID。进程ID是操作系统为每个运行的进程分配的唯一标识符。

以下是一些常用的 `kill` 命令选项：

- `-l`：列出支持的信号列表。
- `-s <信号>`：指定要发送的信号。可以使用信号名称或信号编号。
- `-<信号>`：直接使用信号名称或信号编号发送信号。
- `-p`：不发送信号，仅显示要发送的进程的进程ID。

示例用法：

- `kill 1234`：向进程ID为 1234 的进程发送默认的终止信号（SIGTERM）。
- `kill -9 5678`：向进程ID为 5678 的进程发送强制终止信号（SIGKILL）。
- `kill -l`：列出支持的信号列表。

通过使用 `kill` 命令，你可以对正在运行的进程执行不同的操作，包括终止进程、重新加载配置、发送自定义信号等。常用的信号包括：

- `SIGTERM`：默认的终止信号，用于优雅地终止进程。
- `SIGKILL`：强制终止信号，立即终止进程，不允许进程进行清理操作。
- `SIGHUP`：挂起信号，常用于重新加载配置文件。
- `SIGINT`：中断信号，通常由用户按下 Ctrl+C 触发，用于中断正在运行的程序。

请注意，发送不同的信号可能会导致进程以不同的方式响应。某些信号可能需要特定的权限才能发送。

### `jobs`

`jobs` 是一个命令行工具，用于显示当前终端会话中正在运行或已停止的作业（jobs）。作业是在当前终端会话中以前台或后台方式运行的命令或进程。

`jobs` 命令的基本语法如下：

```zsh
jobs [options]
```

`jobs` 命令不需要额外的参数，它会显示当前终端会话中的作业列表，并为每个作业分配一个唯一的作业号（job number）。作业号用于标识和操作特定的作业。

以下是一些常用的 `jobs` 命令选项：

- `-l`：显示作业列表时，包含作业的进程ID（PID）。
- `-p`：仅显示作业的进程ID（PID），不显示作业号和命令。
- `-r`：仅显示正在运行的作业。
- `-s`：仅显示已停止的作业。

示例用法：

- `jobs`：显示当前终端会话中的所有作业。
- `jobs -r`：仅显示正在运行的作业。
- `jobs -s`：仅显示已停止的作业。

通过使用 `jobs` 命令，你可以查看当前终端会话中的作业状态，包括作业号、命令、进程ID等信息。作业通常与作业控制命令（如 `bg`、`fg`）一起使用，用于将作业放入后台运行、切换前台作业等操作。

请注意，`jobs` 命令只能在交互式终端会话中使用，对于后台运行的作业或其他终端会话中的作业，可能无法显示。